---
order: 30
layout: default
title: Developing Java clients
---
# Overview

This section gives an overview on how to access Cumulocity from Java clients, starting from connecting to Cumulocity over accessing the various databases to remote control of devices. It also discusses how to extend the Cumulocity domain model from Java for new devices and other business objects. Finally, this section describes how to configure the logging service in order to control the level of diagnostic messages generated by the client.

The section is tightly linked to the design of the REST interfaces, which are described in the "REST implementation" section of the reference guide. More details on the Java implementation can be found in the [client library section](guides/reference-guide/client-libraries) of the reference guide.

# Connecting to Cumulocity

The root interface for connecting to Cumulocity from Java is called "Platform" (see "Root interface" in the [REST implementation section](guides/reference-guide/rest-implementation) of the reference guide). It is instantiated as follows:

    Platform platform = new PlatformImpl("<<URL>>", "<<tenant>>", "<<user>>", "<<password>>", "<<application_key>>");

As an example:

    Platform platform = new PlatformImpl("https://developer.cumulocity.com", "demo", "reader", "reader", "uL27no8nhvLlYmW1JIK1CA==");

The root interface provides access to all other interfaces of the platform, such as the inventory.

To simplify dependency management in the SDK, try the automated dependency management feature of Eclipse. Open the manifest file in Eclipse and click on the "Dependencies" tab. At the bottom left, click on "Import-Package". Then click "Add...", type "com.cumulocity", select all bundles and click "Ok". Save the manifest. Now you can develop your Java code as normal. Before you run the code, click the "add dependencies" link on the same page, and all required dependencies will be filled in.

# Accessing the inventory

The following code snippet shows how to obtain a handle to the inventory from Java:

    InventoryApi inventory = platform.getInventoryApi();

Using this handle, you can create, retrieve and update managed objects. For example, if you would like to retrieve all devices that can measure electricity from the inventory, use

    InventoryFilter inventoryFilter = new InventoryFilter();
    inventoryFilter.byFragmentType(SinglePhaseElectricitySensor.class);
    PagedCollectionResource<ManagedObjectCollectionRepresentation> pagedCollectionResource = inventory .getManagedObjectsByFilter(inventoryFilter);

This returns a list of managed objects, which can be very large in practice. To not overload clients, such lists are returned in "pages" of objects. The following code snippet demonstrates iterating over the entire result:

    ManagedObjectCollectionRepresentation mos;
    for (mos = pagedCollectionResource.get(); mos != null; mos = pagedCollectionResource.getNextPage(mos)) {
         for (ManagedObjectRepresentation mo : mos.getManagedObjects()) {
        System.out.println(mo.getName());
      }
    }

Please note that the collection may change while iterating over it. For example, when you retrieve the next page of objects from a client, another client may have deleted all objects in the meantime. Hence you cannot assume at the beginning of the iteration that the collection will stay constant.

To create a new managed object, simply create a local representation of the object and send it to the platform. The following code snippet shows how to create a new electricity meter with a relay in it:

    ManagedObjectRepresentation mo = new ManagedObjectRepresentation();
    mo.setName("MyMeter-1");
    Relay relay = new Relay();
    mo.set(relay);
    SinglePhaseElectricitySensor meter = new SinglePhaseElectricitySensor();
    mo.set(meter);
    // Set additional properties, e.g., tariff tables, ...
    mo = inventory.create(mo);
    System.out.println(mo.getId());

The result of invoking "create" is a version of the new managed object with a populated unique identifier. Now assume that you would like to store additional, own properties along with the device. This can be simply done by creating a new "fragment" in the form of a Java bean. For example, assume that you would like to store tariff information along with your meter. There is a day and a night tariff, and we need to store the hours during which the night time tariff is active:

    public class Tariff {
      public int getNightTariffStart() {
        return nightTariffStart;
      }
      public void setNightTariffStart(int nightTariffStart) {
        this.nightTariffStart = nightTariffStart;
      }
      public int getNightTariffEnd() {
        return nightTariffEnd;
      }
      public void setNightTariffEnd(int nightTariffEnd) {
        this.nightTariffEnd = nightTariffEnd;
      }
      private int nightTariffStart = 22;
      private int nightTariffEnd = 6;
    }

Now, you can simply add tariff information to your meter:

    Tariff tariff = new Tariff();
    mo.set(tariff);

This will store the tariff information along with the meter. For converting Java objects from and towards JSON/REST, Cumulocity uses Svenson. The [Svenson documentation](http://code.google.com/p/svenson/) provides more information on how to influence the JSON format that is produced respectively accepted.

When providing own fragments in the SDK, you need to make the fragments visible to the Cumulocity client libraries. To do this, add the following line to the manifest file of the bundle containing the fragments:

    Eclipse-RegisterBuddy: com.nsn.cumulocity.model.core-model

It is a good practice to maintain your domain model in a separate project in the SDK. That way, you can share the domain model between your agent and your application.

# Accessing the identity service

A device typically has a technical identifier that an agent needs to know to be able to contact the device. Examples are meter numbers, IP addresses and REST URLs. To associate such identifiers with the unique identifier of Cumulocity, agents can use the identity service. Again, to create the association, create an object of type "ExternalIDRepresentation" and send it to the platform. The code snippet below shows how to register a REST URL for a device. It assumes that "mo" is the managed object from the above example and "deviceUrl" is a string with the REST URL of the device.

    final String ASSET_TYPE = "com_cumulocity_idtype_AssetTag";
    final String deviceUrl = "SAMPLE-A-239239232";
            
    ExternalIDRepresentation externalIDGid = new ExternalIDRepresentation();
    externalIDGid.setType(ASSET_TYPE);
    externalIDGid.setExternalId(deviceUrl);
    externalIDGid.setManagedObject(mo);
    IdentityApi identityApi= platform.getIdentityApi();
    identityApi.create(externalIDGid);

Now, if you need the association back, you can just query the identity service as follows:

    ID id = new ID();
    id.setType(ASSET_TYPE);
    id.setValue(deviceUrl);
    externalIDGid = identityApi.getExternalId(id);

The returned object will contain the unique identifier and a link to the managed object.

# Accessing events and measurements

Events and measurements can be accessed in a very similar manner as described above for the inventory. The following example queries all energy measurements in a particular time period. Again, due to the potential size of the query result, a paging mechanism is used.

    MeasurementApi measurementApi = platform.getMeasurementApi();
    MeasurementFilter measurementFilter = new MeasurementFilter();
    Calendar cal = Calendar.getInstance();
    Date toDate = cal.getTime();
    cal.add(Calendar.DATE, -14);
    Date fromDate = cal.getTime();
    measurementFilter.byDate(fromDate, toDate);
    PagedCollectionResource<MeasurementCollectionRepresentation> mr =measurementApi.getMeasurementsByFilter(measurementFilter);
    MeasurementCollectionRepresentation measurements = mr.get();
    for (; measurements != null; measurements = mr
        .getNextPage(measurements)) {
        for (MeasurementRepresentation measurement : measurements
            .getMeasurements()) {
            SinglePhaseEnergyMeasurement energy = measurement
                .get(SinglePhaseEnergyMeasurement.class);
            // ...
        }
    }

# Controlling devices

Finally, the "DeviceControlResource" enables you to manipulate devices remotely. It has two sides: You can create operations in applications to be sent to devices, and you can query operations from agents. In order to control a device it must be in the "childDevices" hierarchy of an agent. An agent is a special kind of ManagedObject which has type="agent", an additional fragment com\_cumulocity\_model\_Agent, and the desired device in the "childDevices" hierarchy, as shown in the following section of code:

    ManagedObjectRepresentation agent = new ManagedObjectRepresentation();
    agent.setType("agent"); // including this one is not mandatory, but it provides meaningful information to user
    agent.set(new com.cumulocity.model.Agent()); // agents must include this fragment
    // ... create agent in inventory
    ManagedObjectRepresentation device = ...;
    // ... create device in inventory
     
    ManagedObjectReferenceRepresentation child2Ref = new ManagedObjectReferenceRepresentation();
    child2Ref.setManagedObject(device);
    inventory.getManagedObject(agent.getId()). addChildDevice(child2Ref);

For example, assume that you would like to switch off a relay in a meter from an application. Similar to the previous examples, you create the operation to be executed locally, and then send it to the platform:

    DeviceControlApi control = platform.getDeviceControlApi();
    OperationRepresentation operation = new OperationRepresentation();
    operation.setDeviceId(mo.getId());
    relay.setRelayState(RelayState.OPEN);
    operation.set(relay);
    control.create(operation);

Now, if you would like to query the pending operations from an agent, the following code would need to be executed:

    OperationFilter operationFilter = new OperationFilter();
    operationFilter.byAgent(mo.getId().getValue());
    operationFilter.byStatus(OperationStatus.PENDING);
    PagedCollectionResource<OperationCollectionRepresentation> pagedOperationCollection = control.getOperationsByFilter(operationFilter);

Again, the returned result may come in several pages due to its potential size.

    OperationCollectionRepresentation opCollectionRepresentation;
    for (opCollectionRepresentation = pagedOperationCollection.get(); opCollectionRepresentation != null; opCollectionRepresentation = pagedOperationCollection.getNextPage(opCollectionRepresentation)) {
        for (OperationRepresentation op : opCollectionRepresentation.getOperations()) {
           System.out.println(op.getStatus());
        }
    }

# Logging Configuration

Logging in the Java client SDK is handled through [slf4j](http://www.slf4j.org/) with a [logback](http://logback.qos.ch) backend. For a detailed description on how to use and configure logging, see the logback [documentation](http://logback.qos.ch/documentation.html).

Since version 0.11, the default logging level of the SDK is set to "Error" for all components, which means that logging messages are suppressed unless their level is "Error", so if everything runs smoothly, there should be no log messages generated by the SDK. By default, log messages are sent to the console only.

The default logging configuration can be changed by providing a new configuration file. Two methods for providing the configuration file are discussed here: via an absolute filename passed using a system property; and via an OSGi fragment. Note that both of these methods **override** the default behaviour, rather than extending it.

## Configuration via System Property

The absolute path to a logging configuration file can be passed using the following system property:

    -Dlogback.configurationFile=/path/to/config.xml

In Eclipse, this property should be added on the *Arguments-\>VM Arguments* of the *Run Configuration* window.

## Configuration via OSGi Fragment Bundle

A more flexible approach is to provide the logger configuration via an OSGi bundle that can be deployed along with the client. From within Eclipse, the fragment can be generated as follows:

1.  Create a new project of type "*Fragment Project*" called "*LogConfig*"
    -   Target to run with: an OSGi framework
    -   Host plugin ID: **ch.qos.logback.classic**

2.  Add a file called *logback.xml* to the root of the new project. This file will contain the logging configuratiom.
3.  Edit the MANIFEST.MF file and add the following:
    -   On the *Build* page add the *logback.xml* file to the *Binary Build*

4.  On the *Bundles* page of the *Run Configuration *dialog of the Java client project:
    -   Select the *LogConfig* bundle
    -   Deselect the *com.nsn.cumulocity.platform-services.sdk.logging-config* bundle

## Simple Logging Configuration

The following example shows how to enable debug-level logging for a single component, called "*com.cumulocity.javaclient*", whilst keeping error-level logging for all other components. The following code snippet shows how to create the logger, and to log a message:

    Logger logger = LoggerFactory.getLogger("com.cumulocity.javaclient");logger.debug("A debug message");

The configuration file looks like this:

    <configuration>  <appender name="STDOUT" class="ch.qos.logback.core.ConsoleAppender">    <encoder>      <pattern>%d{HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n</pattern>    </encoder>  </appender>  <logger name="com.cumulocity.javaclient" level="debug"/>  <root level="error">    <appender-ref ref="STDOUT" />  </root></configuration>

When the code is run, the console should contain a message similar to the following:

    21:52:02.790 [Start Level Event Dispatcher] DEBUG com.cumulocity.javaclient - A debug message


